#!/usr/bin/python
# 
# Version | Last Mod    | Author          | Description
# ------- + ----------- + --------------- + -----------------------------------
# 1.0     | 2016-10-06  | @brkr19         | First release
#------------------------------------------------------------------------------

import argparse
import sqlite3
import logging
from sets import Set
import subprocess
import re
import datetime

LOGFILE = "/var/log/wifi_scan.log"
network_interface = "" # set in initialize()
database_path = ""  # set in initialize()
topic_arn = ""  # set in initialize()
watched_networks = Set([])
logger = None
network_database = None


class NetworkDatabase(object):

    def __init__(self, database_path):
        self._db_connection = sqlite3.connect(database_path, detect_types=sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES)
        self._db_connection.row_factory = sqlite3.Row
        self._db_cur = self._db_connection.cursor()
        
        self._db_connection.execute("""
            CREATE TABLE IF NOT EXISTS networks (
                essid       TEXT    NOT NULL,
                bssid       TEXT    NOT NULL,
                channel     INT     NOT NULL,
                signal      INT,
                first_seen  TIMESTAMP,
                last_seen   TIMESTAMP,
                last_scan   TIMESTAMP,
                last_state  INT,
                PRIMARY KEY (essid, bssid, channel));
            """)

    def getAll(self):
        logger = logging.getLogger('main')
        results = {}

        query = """
            SELECT essid, bssid, channel, signal, first_seen, last_seen, last_scan, last_state
            FROM networks"""

        self._db_cur.execute(query)

        for row in self._db_cur:
            network = WirelessNetwork(essid=row['essid'], bssid=row['bssid'],
                channel=row['channel'], signal=row['signal'], first_seen=row['first_seen'],
                last_seen=row['last_seen'], last_scan=row['last_scan'],
                last_state=row['last_state'])

            results[network.getKey()] = network

        return results

    def add(self, network):
        query = """
            INSERT INTO networks (essid, bssid, channel, signal, first_seen, last_seen,
                last_scan, last_state) 
            VALUES (?,?,?,?,?,?,?,?);"""

        try:
            self._db_connection.execute(query, (network.essid, network.bssid, network.channel,
                network.signal, network.first_seen, network.last_seen, network.last_scan,
                network.last_state))
        
            self._db_connection.commit()

        except sqlite3.IntegrityError:
            logger = logging.getLogger('main')
            logger.error('Key already exists in PRIMARY KEY [{}]'.format(network.getKey()))

    def update(self, network):
        logger = logging.getLogger('main')
        query = """
            UPDATE networks SET signal=?, first_seen=?, last_seen=?, last_scan=?, last_state=?
            WHERE essid=? AND bssid=? AND channel=?;"""

        try:
            logger.debug("About to update {}".format(network.getKey()))
            self._db_cur.execute(query, (network.signal, network.first_seen, 
                network.last_seen, network.last_scan, network.last_state,
                network.essid, network.bssid, network.channel))
        
            self._db_connection.commit()
            logger.debug("Number of rows updated: {}".format(self._db_cur.rowcount))

        except sqlite3.Error as e:
            logger = logging.getLogger('main')
            logger.error('Problems updating {}: [{}]'.format(e.args[0], network.getKey()))

    def __del__(self):
        self._db_connection.close()

#******************************************************************************
#  The WirelessNetwork class definition
#******************************************************************************

class WirelessNetwork():
    """A simple class to store data about a wireless network"""

    def __init__(self, essid, bssid, channel, signal, first_seen=None, last_seen=None,
                    last_scan=None, alert_requested=False, last_state=None):

        """Initialize the network object"""
        self.essid = essid
        self.bssid = bssid
        self.channel = str(channel)
        self.signal = str(signal)
        self.first_seen = first_seen
        self.last_seen = last_seen
        self.last_scan = last_scan
        self.alert_requested = alert_requested
        self.last_state = str(last_state)
    
    def __hash__(self):
        return (self.essid + self.bssid + self.channel).__hash__()

    def __eq__(self, item):
        if isinstance(item, WirelessNetwork):
            return self.essid == item.essid and self.bssid == item.bssid and self.channel == item.channel
        else:
            return False

    def __str__( self ):
        return (("[WirelessNetwork] essid:'{}' bssid:'{}' channel:'{}' signal:'{}' first_seen:'{}'"
                    " last_seen:'{}' last_scan:'{}' alert_requested:'{}' last_state:'{}'")
                .format(self.essid, self.bssid, self.channel, self.signal, self.first_seen,
                    self.last_seen, self.last_scan, self.alert_requested, self.last_state))

    def getKey(self):
        return "|" + self.essid + "|" + self.bssid + "|" + self.channel + "|"

def initialize():
    global network_database
    global network_interface
    global topic_arn
    global known_networks

    parser = argparse.ArgumentParser(
        description='This script tracks the detection of ESSIDs on an interface and can send'
                    'notifications when a new one appears or one disappears'
        )

    parser.add_argument('--interface', 
        required=True, 
        help='network interface to scan from')
    parser.add_argument('--essid', 
        required=True, 
        action='append',
        help='essid to alert on (can be repeated)')
    parser.add_argument('--database', 
        required=True, 
        help='sqlite database to store results')
    parser.add_argument('--topic-arn', 
        help='Optional: AWS SNS topic ARN')


    # Parse the command line arguments
    logger = logging.getLogger('main')
    logger.debug("Initializing wifi_scan.py")

    args = parser.parse_args()
    arg_count=0

    network_interface = args.interface
    logger.debug("The {} interface will do the scanning".format(network_interface))
    database_path = args.database
    logger.debug("The database will be stored in {}".format(database_path))

    if args.topic_arn is not None:
        topic_arn = args.topic_arn
        logger.debug("The SNS topic will be: {}".format(topic_arn))

    for essid in args.essid:
        logger.debug("Setting an alert for: {}".format(essid))
        watched_networks.add(essid)

    network_database = NetworkDatabase(database_path)

def get_current_networks(network_interface, scan_time):
    logger = logging.getLogger('main')
    
    CELL_TAG="\sCell\s\d+ - Address: "
    
    BSSID_TAG="((?:[0-9A-H]{2}:){5}[0-9A-H]{2})"
    CHANNEL_TAG="\sChannel:(\d+)"
    SIGNAL_TAG="\sQuality.*Signal level=([-\d]+)"
    ESSID_TAG="\sESSID:\"(.*)\""
    FULL_TAG=BSSID_TAG + "[\S\s]*" + CHANNEL_TAG + "[\S\s]*" + SIGNAL_TAG + "[\S\s]*" + ESSID_TAG

    last_scan = scan_time
    iwlist_command = ["/sbin/iwlist", network_interface, "scan"]
    results = subprocess.Popen(iwlist_command, stdout=subprocess.PIPE).communicate()[0]
    networks = {}

    cell_start = re.compile(CELL_TAG)
    cells = cell_start.split(results)

    for cell in cells:
        bssid=""
        essid=""
        channel=""
        signal=""
        last_seen=""
        alert_requested=False

        capture = re.match(FULL_TAG, cell)

        if capture is not None:
            last_seen = scan_time

            bssid = capture.group(1)
            channel = capture.group(2)
            signal = capture.group(3)
            essid = capture.group(4)

            if essid in watched_networks:
                alert_requested=True

            network = WirelessNetwork(essid=essid, bssid=bssid, channel=channel, signal=signal, 
                last_seen=last_seen, last_scan=last_scan, alert_requested=alert_requested)
            networks[network.getKey()] = network

    return networks

def sendAlert(topic, message):
    logger = logging.getLogger('main')

    iwlist_command = (["/usr/local/bin/aws", "sns", "publish", "--topic-arn", topic,
        "--subject", "Spruce Goose", "--message", message])

    results = subprocess.Popen(iwlist_command, stdout=subprocess.PIPE).communicate()[0]

    logger.debug("Results of AWS call: {}".format(results))


#******************************************************************************
#  The main function kicks off all of the work
#******************************************************************************

def main():

    # Set up logging
    logger = logging.getLogger('main')
    logger.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')

    # Debug Handler - writes debug+ to the console
    debug_log_handler = logging.StreamHandler()
    debug_log_handler.setLevel(logging.DEBUG)
    debug_log_handler.setFormatter(formatter)
    logger.addHandler(debug_log_handler)

    # Info Handler - writes info+ to a log file
    info_log_handler = logging.FileHandler(LOGFILE)
    info_log_handler.setLevel(logging.INFO)
    info_log_handler.setFormatter(formatter)
    logger.addHandler(info_log_handler)

    initialize()

    scan_time = datetime.datetime.now().utcnow()

    known_networks = network_database.getAll()
    current_networks = get_current_networks(network_interface, scan_time)

    if current_networks is not None:
        for key, network in current_networks.iteritems():

            # Check if the current network key is in the list of known networks
            if known_networks is not None and key in known_networks:
                known_network = known_networks[key]

                # This is a known network, now check if it was online during the last scan
                if known_network.last_scan != known_network.last_seen:
                    known_network.last_state = 1

                    message = "{} is back ONLINE on {}".format(key, network_interface)
                    if network.essid in watched_networks:
                        logger.warning("ALERT: {}".format(message))
                        sendAlert(topic_arn, message)
                    else:
                        logger.warning("QUIET: {}".format(message))

    
                known_network.signal = network.signal
                known_network.last_seen = network.last_seen
                known_network.last_scan = network.last_scan

                network_database.update(known_network)

            # First time seeing this network
            else:
                network.first_seen = network.last_seen
                network.last_scan = network.last_seen
                network.last_state = 1

                message = "{} is ONLINE for the first time on {}".format(key, network_interface)
                if network.essid in watched_networks:
                    logger.warning("ALERT: {}".format(message))
                    sendAlert(topic_arn, message)

                else:
                    logger.warning("QUIET: {}".format(message))

                network_database.add(network)
               
    else:
        logger.warning("No networks were discovered on {}".format(network_interface))
    
    #Update the scanned date for all
    logger.warning("Updating the scanned dates for all known networks")
    if known_networks is not None:
        for key, known_network in known_networks.iteritems():
            known_network.last_scan = scan_time
            network_database.update(known_network)


    #Check to see which ones disappeared
    known_networks = network_database.getAll()
    if known_networks is not None:
        for key, known_network in known_networks.iteritems():
            if (known_network.last_scan != known_network.last_seen and 
                known_network.last_state == "1"):

                message = "{} is OFFLINE on {}".format(key, network_interface)
                if known_network.essid in watched_networks:
                    logger.warning("ALERT: {}".format(key))
                    sendAlert(topic_arn, message)
                else:
                    logger.warning("QUIET: {}".format(key))

                known_network.last_state = 0
                network_database.update(known_network)

if __name__ == "__main__": main()



